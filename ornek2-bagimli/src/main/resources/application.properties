# Web sunucusu portu
server.port=8080

# Veritabanı (H2) ayarları
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# RabbitMQ ayarları (Docker Compose servisi ile eşleşmeli)
spring.rabbitmq.host=rabbitmq
spring.rabbitmq.port=5672


# --- Actuator uç noktalarını etkinleştirme ----------------------------------------------------------
# --- health
# management.endpoints.web.exposure.include=health
# http://localhost:8080/actuator/health Adresine erişim sağlar ve
# {"status":"UP"} JSON cevabı döner

# --- probes
# probes eklemek, health endpoint’inin detaylı alt uç noktalarını (özellikle liveness/readiness)
# aktif hale getirir. Yani health ile birlikte eklenmesi gerekir.
# Sadece probes eklenirse, health endpoint’i devre dışı kalır.
# http://localhost:8080/actuator çıktısı aşağıdaki gibi olur:
#    {
#     "_links": {
#       "self": {
#         "href": "http://localhost:8080/actuator",
#         "templated": false
#       }
#     }
#   }
#
# health ve probes birlikte eklenirse:
# http://localhost:8080/actuator çıktısı aşağıdaki gibi olur:
#   {
#     "_links": {
#       "self": {
#         "href": "http://localhost:8080/actuator",
#         "templated": false
#       },
#       "health": {
#         "href": "http://localhost:8080/actuator/health",
#         "templated": false
#       },
#       "health-path": {
#         "href": "http://localhost:8080/actuator/health/{*path}",
#         "templated": true
#       }
#     }
#   }
#
# http://localhost:8080/actuator/health çıktısı aşağıdaki gibi olur:
#   { "status": "UP" }
management.endpoints.web.exposure.include=health,probes


# http://localhost:8080/actuator çıktısı aşağıdaki gibi olur:
#      {
#        "_links": {
#          "self": {
#            "href": "http://localhost:8080/actuator",
#            "templated": false
#          },
#          "health": {
#            "href": "http://localhost:8080/actuator/health",
#            "templated": false
#          },
#          "health-path": {
#            "href": "http://localhost:8080/actuator/health/{*path}",
#            "templated": true
#          }
#        }
#      }
# http://localhost:8080/actuator/health çıktısı aşağıdaki gibi olur:
#    {
#      "status": "UP",
#      "groups": [
#        "liveness",
#        "readiness"
#      ]
#    }
# Aşağıdaki uç noktalar web üzerinden erişilebilir hale gelsin diye eklenmiştir:
# http://localhost:8080/actuator/health/liveness
#     {"status":"UP"}
# http://localhost:8080/actuator/health/readiness
#     {"status":"UP"}
management.endpoint.health.probes.enabled=true

# Health grup tanımlamaları
# `group.liveness`, liveness probe’a hangi health indicator’ların dahil edileceğini belirtmek için kullanılır.
# Genellikle liveness grubuna özel indicator eklenmez, çünkü liveness sadece uygulamanın "çöküp çökmediğini" anlamak içindir.
# # # management.endpoint.health.group.liveness.include=livenessState

# Readiness probu için gerekli yapılandırma
# Ağ bağlantısı, DB bağlantısı gibi dış bağımlılıklar readiness grubuna eklenir, liveness’e değil.
# Eğer readinessState’i readiness grubundan çıkarırsanız, uygulama "ben hazır değilim" dese bile, probe UP döndürmeye devam eder.
# Spring Boot, RabbitMQ için otomatik olarak rabbit adında bir health indicator sağlar.
# Memcached için ise kendi health indicator’unuzu yazmanız gerekir (örneğin memoryCache adında), çünkü Spring Boot varsayılan olarak Memcached health indicator sağlamaz.
#        @Component("memoryCache")
#        public class MemcachedHealthIndicator implements HealthIndicator {
#            @Override
#            public Health health() {
#                try {
#                    // Memcached bağlantısını test et
#                    if (memcachedClient.isConnected()) {
#                        return Health.up().withDetail("server", "connected").build();
#                    } else {
#                        return Health.down().withDetail("reason", "not connected").build();
#                    }
#                } catch (Exception e) {
#                    return Health.down().withException(e).build();
#                }
#            }
#        }
# management.endpoint.health.group.readiness.include=readinessState,db,mongo,rabbit,diskSpace,kafka
management.endpoint.health.group.readiness.include=readinessState,rabbit,db


